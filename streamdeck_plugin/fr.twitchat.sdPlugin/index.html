<!DOCTYPE HTML>
<html>

<head>
	<title>fr.twitchat</title>
	<meta charset="utf-8" />
	<script type="text/javascript" src="js/obs-websocket.js"></script>
	<script type="text/javascript" src="js/action.js"></script>
	<script type="text/javascript" src="js/constants.js"></script>
	<script type="text/javascript" src="js/prototypes.js"></script>
	<script type="text/javascript" src="js/timers.js"></script>
	<script type="text/javascript" src="js/utils.js"></script>
	<script type="text/javascript" src="js/events.js"></script>
	<script type="text/javascript" src="js/api.js"></script>
	<script type="text/javascript" src="js/stream-deck.js"></script>
	<script type="text/javascript" src="js/property-inspector.js"></script>
	<script type="text/javascript" src="js/dynamic-styles.js"></script>
</head>

<body>
	<script>
		var uuidList = [
			"fr.twitchat.action.greet-feed-read-all",
			"fr.twitchat.action.greet-feed-read",
			"fr.twitchat.action.chat-feed-read-all",
			"fr.twitchat.action.chat-feed-read",
			"fr.twitchat.action.chat-feed-read-encoder",
			"fr.twitchat.action.chat-feed-pause",
			"fr.twitchat.action.chat-feed-unpause",
			"fr.twitchat.action.chat-feed-scroll-up",
			"fr.twitchat.action.chat-feed-scroll-down",
			"fr.twitchat.action.chat-feed-scroll",
			"fr.twitchat.action.poll-toggle",
			"fr.twitchat.action.prediction-toggle",
			"fr.twitchat.action.bingo-toggle",
			"fr.twitchat.action.raffle-toggle",
			"fr.twitchat.action.viewers-count-toggle",
			"fr.twitchat.action.mod-tools-toggle",
			"fr.twitchat.action.censor-deleted-messages-toggle",
			"fr.twitchat.action.shoutout",
			"fr.twitchat.action.set-emergency-mode",
			"fr.twitchat.action.stop-tts",
			"fr.twitchat.action.enable-stt",
			"fr.twitchat.action.disable-stt",
		];

		let websocket = null;
		let websocketOBS = new OBSWebSocket();
		let websocketOBS_firstConnect = true;
		let pluginUUID = null;
		let reconnectTimeout = null;
		let connecting = false;
		const settingsCache = {
			OBSWS_PORT: "4455",
			OBSWS_PASS: "",
			OBSWS_IP: "127.0.0.1",
			OBSWS_CONNECTED: false,
			COLS_COUNT: 1,
		};

		var actions = {

			onKeyUp: (action, payload) => {
				console.log("KEY UP", action, payload);
				const actionName = action.replace("fr.twitchat.action.", "").replace(/-/gi, "_").toUpperCase();
				const col = payload.settings.colIndex ?? 0;
				let params;
				switch(actionName) {
					case "GREET_FEED_READ":{
						params = {count: payload.settings.readCount};
						break;
					}
					case "CHAT_FEED_READ":{
						params = {col, count: payload.settings.readCount};
						break;
					}
					case "CHAT_FEED_SCROLL_UP":{
						params = {col, scrollBy: payload.settings.scrollAmount};
						break;
					}
					case "CHAT_FEED_SCROLL_DOWN":{
						params = {col, scrollBy: payload.settings.scrollAmount};
						break;
					}
				}
				// console.log(actionName, params);
				callTwitchat(actionName, params)
			},

			onDialRotate: (action, payload) => {
				let actionName = action.UUID.replace("fr.twitchat.action.", "").replace(/-/gi, "_").toUpperCase();
				let params;
				const col = payload.settings.colIndex ?? 0;
				
				switch(actionName) {
					case "CHAT_FEED_SCROLL":{
						params = { col, scrollBy: payload.ticks };
						break;
					}
					case "CHAT_FEED_READ_ENCODER":{
						actionName = "CHAT_FEED_READ";
						params = { col, count: payload.ticks };
						break;
					}
				}
				console.log(actionName, params);
				// console.log(actionName, params);
				callTwitchat(actionName, params);
			},

			onDialPress: (action, payload) => {
				let actionName = action.UUID.replace("fr.twitchat.action.", "").replace(/-/gi, "_").toUpperCase();
			},

			onTouchTap: (action, payload) => {
				const actionName = action.UUID.replace("fr.twitchat.action.", "").replace(/-/gi, "_").toUpperCase();
				const px = payload.tapPos[0];
				const py = payload.tapPos[1];
				const col = payload.settings.colIndex ?? 0;
				let params;
				switch(actionName) {
					case "CHAT_FEED_SCROLL":{
						if(px < 200 / 3){
							callTwitchat("CHAT_FEED_SCROLL_BOTTOM", {col});
						}else if(px < 200 / 3 * 2){
							callTwitchat("CHAT_FEED_SCROLL_DOWN", {
								col,
								scrollBy:settingsCache.CHAT_FEED_SCROLL_DOWN
							});
						}else{
							callTwitchat("CHAT_FEED_SCROLL_UP", {
								col,
								scrollBy:settingsCache.CHAT_FEED_SCROLL_UP
							});
						}
						return;
					}
					case "CHAT_FEED_READ_ENCODER":{
						if(px < 200 / 3){
							callTwitchat("CHAT_FEED_READ_ALL", {col});
						}else if(px < 200 / 3 * 2){
							callTwitchat("CHAT_FEED_READ", {
								col,
								count:settingsCache.CHAT_FEED_READ
							});
						}else{
							callTwitchat("CHAT_FEED_READ", {
								col,
								count:-settingsCache.CHAT_FEED_READ
							});
						}
						return;
					}
				}
				console.log("TAP", actionName, params);
				callTwitchat(actionName, params);
			},

			SetGlobalSettings: (settings) => {
				$PI.setGlobalSettings(settings);
			},

			GetGlobalSettings: () => {
				$PI.getGlobalSettings();
			},

			AddToSettings: (context, newSettings) => {
				settingsCache[context] = newSettings;
			}
		};
		
		window.onload = ()=> {
			console.log("okkfodfd")

			$PI.onDidReceiveGlobalSettings((e) => {
				settingsCache.OBSWS_PASS = e.payload.settings.OBSWS_PASS;
				settingsCache.OBSWS_PORT = e.payload.settings.OBSWS_PORT;
				settingsCache.OBSWS_IP = e.payload.settings.OBSWS_IP;
				obsConnect();
			});
			
			$SD.onConnected(({ actionInfo, appInfo, connection, messageType, port, uuid }) => {
				console.log('Stream Deck connected!', uuid);

				//Dunno why we have to use $PI instead of $SD...
				$PI.getGlobalSettings();
			});
			$SD.on("keyUp", (e)=>{
				console.log("ON KEYUP", e);
			})
			
			for (let i = 0; i < uuidList.length; i++) {
				const uuid = uuidList[i];
				
				const myAction = new Action(uuid);
				myAction.onKeyUp(({ action, context, device, event, payload }) => {
					actions.onKeyUp(myAction, payload);
				});
		
				myAction.onDialPress(({ action, context, device, event, payload }) => {
					actions.onDialPress(myAction, payload);
				});
		
				myAction.onDialRotate(({ action, context, device, event, payload }) => {
					actions.onDialRotate(myAction, payload);
				});
		
				myAction.onTouchTap(({ action, context, device, event, payload }) => {
					actions.onTouchTap(myAction, payload);
				});
		
				myAction.onSendToPlugin(({ action, context, device, event, payload }) => {

					if(payload.OBSW_DO_CONNECT) {
						settingsCache.OBSWS_PASS = payload.OBSW_DO_CONNECT.pass;
						settingsCache.OBSWS_PORT = payload.OBSW_DO_CONNECT.port;
						settingsCache.OBSWS_IP = payload.OBSW_DO_CONNECT.ip;
						actions.SetGlobalSettings(settingsCache);
						obsConnect();
					}

					if(payload.TEST_ACTION != undefined) {
						var settings = payload['settings'];
						actions.onKeyUp(payload.TEST_ACTION);
					}
				});
			}

		};

		/**
		 * Connect to OBS via OBS-websocket
		 */
		function obsConnect() {
			if(!settingsCache.OBSWS_PORT) return;
			if(connecting || settingsCache.OBSWS_CONNECTED === true) return;
			connecting = true;//Avoid double websocketOBS.connect() calls that messes up obs-ws
			try {
				const ip = settingsCache.OBSWS_IP? settingsCache.OBSWS_IP : "127.0.0.1";
				websocketOBS.connect("ws://"+ip+":"+settingsCache.OBSWS_PORT, settingsCache.OBSWS_PASS, {rpcVersion:1})
				.then(()=> {
					connecting = false;
					const changed = settingsCache.OBSWS_CONNECTED != true;
					settingsCache.OBSWS_CONNECTED = true;
					//If state has changed, tell the property inspector
					if(changed) actions.SetGlobalSettings(settingsCache);
					callTwitchat("GET_COLS_COUNT");
				});
			}catch(error) {
				console.log("FAILED");
				console.log(error);
				connecting = false;
				clearTimeout(reconnectTimeout);
				reconnectTimeout = setTimeout(()=> {
					obsConnect();
				}, 5000);
				return false;
			}

			if(websocketOBS_firstConnect) {
				websocketOBS_firstConnect = false;

				//Listen for socket connection close to auto reconnect
				websocketOBS.addListener("ConnectionClosed", (e)=> {
					connecting = false;
					console.log("Connection closed", e);
					const changed = settingsCache.OBSWS_CONNECTED != false;
					settingsCache.OBSWS_CONNECTED = false;
					//If state has changed, tell the property inspector
					if(changed) actions.SetGlobalSettings(settingsCache);
					clearTimeout(reconnectTimeout);
					reconnectTimeout = setTimeout(()=> {
						obsConnect();
					}, 5000);
				});
	
				//Listen for Twitchat events. Unnecessary for now
				websocketOBS.on("CustomEvent", (e) => {
					if(e.type == undefined) return;
					if(e.origin != "twitchat") return;
					
					switch(e.type) {
						case "SET_COLS_COUNT":{
							console.log("SET COLS COUNT", e.data.count);
							settingsCache.COLS_COUNT = e.data.count;
							//If state has changed, tell the property inspector
							actions.SetGlobalSettings(settingsCache);
							break;
						}
					}
				});
			}
		}

		/**
		 * Request Twitchat to perform an action
		 */
		function callTwitchat(actionName, data) {
			console.log(data);
			if(!data) data = {};
			const eventData = { origin:"twitchat", type:actionName, data:JSON.parse(JSON.stringify(data)) }
			websocketOBS.call("BroadcastCustomEvent", {eventData});
		}
	</script>

</body>

</html>